<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Agar.io - Neural Client (Final)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', sans-serif; user-select: none; transition: background 0.3s; }
        canvas { display: block; }
        
        #menuOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; z-index: 10; }
        .menu-container { display: flex; gap: 20px; }
        .menu-box { background: white; padding: 30px; border-radius: 15px; text-align: center; width: 320px; box-shadow: 0 0 50px rgba(0,0,0,0.8); display: flex; flex-direction: column; }
        .server-list-box { background: white; padding: 20px; border-radius: 15px; width: 300px; box-shadow: 0 0 50px rgba(0,0,0,0.8); display: flex; flex-direction: column; }
        
        input { padding: 12px; width: 85%; margin-bottom: 20px; font-size: 16px; border: 2px solid #ddd; border-radius: 8px; outline: none; }
        input:focus { border-color: #2ecc71; }
        button { padding: 12px; font-size: 16px; border: none; border-radius: 8px; cursor: pointer; width: 100%; font-weight: bold; margin-bottom: 10px; transition: 0.2s; }
        
        #playBtn { background: #2ecc71; color: white; } #playBtn:hover { background: #27ae60; }
        #specBtn { background: #3498db; color: white; } #specBtn:hover { background: #2980b9; }
        
        #themeBtn { position: absolute; top: 15px; right: 230px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 15px; font-size: 14px; cursor: pointer; border-radius: 20px; pointer-events: auto; width: auto; margin: 0; }
        #themeBtn:hover { background: rgba(255,255,255,0.2); }

        .server-item { padding: 10px; margin-bottom: 5px; border-radius: 5px; cursor: pointer; background: #f0f0f0; display: flex; justify-content: space-between; align-items: center; }
        .server-item:hover { background: #e0e0e0; }
        .server-item.selected { background: #d5f5e3; border: 1px solid #2ecc71; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #ccc; }
        .status-online { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; }

        #hud { position: absolute; top: 15px; left: 15px; color: white; font-weight: bold; font-size: 20px; text-shadow: 2px 2px 4px black; pointer-events: none; }
        #leaderboardBox { position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.4); color: white; padding: 10px; border-radius: 8px; width: 200px; pointer-events: none; }
        #lbList { list-style: none; padding: 0; margin: 0; font-size: 14px; }
        #lbList li { display: flex; justify-content: space-between; padding: 2px 0; }
        .lb-me { color: #f1c40f; font-weight: bold; }
    </style>
</head>
<body>
    <button id="themeBtn">Toggle Theme</button>
    
    <div id="menuOverlay">
        <div class="menu-container">
            <div class="menu-box">
                <h2 style="margin-top:0;">Agar.io AI Server</h2>
                <input type="text" id="nickname" placeholder="Enter Nickname" maxlength="15">
                <button id="playBtn">Play Game</button>
                <button id="specBtn">Spectate</button>
            </div>
            <div class="server-list-box">
                <h3 style="margin:0 0 10px 0; border-bottom:1px solid #eee; padding-bottom:10px;">Servers</h3>
                <div id="serverListContainer" style="overflow-y:auto; height:250px;">Loading...</div>
                <button onclick="fetchServerList()" style="margin-top:auto; background:#95a5a6; color:white; padding:8px;">Refresh</button>
            </div>
        </div>
    </div>
    
    <div id="hud">FPS: <span id="fps">0</span> | Mass: <span id="massDisplay">0</span></div>
    <div id="leaderboardBox"><h4 style="margin:0 0 5px 0; text-align:center;">Leaderboard</h4><ul id="lbList"></ul></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const MASTER_URL = "http://localhost:8080/list";
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let socket, myId = -1, mapSize = { w: 6000, h: 6000 };
        let gameState = { players: [], food: [], viruses: [], ejected: [], leaderboard: [] };
        let localPlayers = {};
        
        let camX = 0, camY = 0, camScale = 0.5;
        let targetCamScale = 0.5; 
        let userZoomModifier = 1.0;
        let isDarkTheme = true;
        
        let mouseX = 0, mouseY = 0;
        let isPlaying = false, isSpectating = false, isDead = true; 
        let servers = [], currentServerUrl = null;
        
        let specFollowMode = true; 

        async function fetchServerList() {
            const c = document.getElementById('serverListContainer');
            c.innerHTML = '<div style="padding:10px; color:#888;">Fetching...</div>';
            try {
                const res = await fetch(MASTER_URL);
                servers = await res.json();
                c.innerHTML = '';
                if(servers.length === 0) c.innerHTML = '<div style="padding:10px;">No servers.</div>';
                servers.forEach((s, i) => {
                    const div = document.createElement('div');
                    div.className = 'server-item' + (s.url===currentServerUrl?' selected':'');
                    div.innerHTML = `<span class="status-dot ${s.status==='online'?'status-online':''}"></span> <span>${s.name}</span> <small>${s.players}/${s.max_players}</small>`;
                    if(s.status==='online') div.onclick = () => { currentServerUrl = s.url; connect(); renderServerList(); };
                    c.appendChild(div);
                });
                if(!currentServerUrl && servers.length > 0) { currentServerUrl = servers[0].url; connect(); }
            } catch(e) { c.innerHTML = 'Master Offline'; }
        }
        function renderServerList() { fetchServerList(); } 

        function connect() {
            if(socket) {
                socket.onclose = null; 
                socket.close();
            }

            if(!currentServerUrl) return;
            
            socket = new WebSocket(currentServerUrl);
            
            socket.onopen = () => { 
                console.log("Connected to " + currentServerUrl);
                isPlaying = false;
                isSpectating = false;
                isDead = true;
                localPlayers = {};
                showMenu("Play Game");
            };
            
            socket.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                if(msg.type === 'init') { 
                    myId = msg.id; 
                    mapSize = msg.map; 
                }
                else if(msg.type === 'update') { 
                    processUpdate(msg.data); 
                }
                else if (msg.type === 'death') {
                    isDead = true;
                    isPlaying = false;
                    isSpectating = false;
                    showMenu("Respawn");
                }
            };
            
            socket.onclose = () => { 
                console.log("Disconnected - Reconnecting...");
                isPlaying = false;
                isSpectating = false;
                isDead = true;
                localPlayers = {}; 
                showMenu("Play Game"); 
                
                if (socket.readyState === WebSocket.CLOSED) {
                    setTimeout(connect, 2000); 
                }
            };
        }

        function processUpdate(data) {
            gameState.food = data.food;
            gameState.viruses = data.viruses;
            gameState.ejected = data.ejected;
            gameState.leaderboard = data.leaderboard;
            updateLeaderboard();

            const activeIds = new Set();
            data.players.forEach(p => {
                activeIds.add(p.id);
                if(!localPlayers[p.id]) localPlayers[p.id] = { ...p, renderCells: p.cells.map(c=>({...c})) };
                else {
                    localPlayers[p.id].targetCells = p.cells;
                    localPlayers[p.id].name = p.name;
                    if(localPlayers[p.id].renderCells.length !== p.cells.length) 
                        localPlayers[p.id].renderCells = p.cells.map(c=>({...c}));
                }
            });
            Object.keys(localPlayers).forEach(id => { if(!activeIds.has(parseInt(id))) delete localPlayers[id]; });
        }

        function showMenu(playText) {
            document.getElementById('menuOverlay').style.display = 'flex';
            document.getElementById('playBtn').innerText = playText;
        }

        document.getElementById('playBtn').onclick = () => {
            if (isPlaying && !isDead) {
                document.getElementById('menuOverlay').style.display = 'none';
                return;
            }
            const name = document.getElementById('nickname').value || "Guest";
            socket.send(JSON.stringify({ type: 'join', name: name }));
            isPlaying = true; 
            isSpectating = false;
            isDead = false;
            document.getElementById('menuOverlay').style.display = 'none';
        };
        
        document.getElementById('specBtn').onclick = () => {
            socket.send(JSON.stringify({ type: 'spectate' }));
            isPlaying = false; isSpectating = true;
            specFollowMode = true; 
            document.getElementById('menuOverlay').style.display = 'none';
        };

        document.getElementById('themeBtn').onclick = () => {
            isDarkTheme = !isDarkTheme;
            document.body.style.backgroundColor = isDarkTheme ? '#111' : '#fff';
        };

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                const menu = document.getElementById('menuOverlay');
                if (menu.style.display === 'none') {
                    showMenu(isPlaying && !isDead ? "Resume Game" : "Play Game");
                } else {
                    if (isPlaying && !isDead) menu.style.display = 'none';
                }
            }
            if (e.code === 'KeyQ' && isSpectating) specFollowMode = !specFollowMode;
            if (!isPlaying || isDead) return;
            if (e.code === 'Space') socket.send(JSON.stringify({ type: 'split' }));
            if (e.code === 'KeyW') socket.send(JSON.stringify({ type: 'eject' }));
        });

        window.addEventListener('wheel', (e) => {
            if (isPlaying || isSpectating) {
                userZoomModifier += e.deltaY * -0.001;
                userZoomModifier = Math.max(0.3, Math.min(2.0, userZoomModifier));
            }
        }, { passive: true });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left - canvas.width/2) / camScale + camX;
            mouseY = (e.clientY - rect.top - canvas.height/2) / camScale + camY;
        });

        setInterval(() => {
            if(socket && socket.readyState === 1) {
                let tx, ty;
                if (isPlaying) {
                    tx = isNaN(mouseX) ? mapSize.w/2 : mouseX;
                    ty = isNaN(mouseY) ? mapSize.h/2 : mouseY;
                } else if (isSpectating) {
                    tx = camX;
                    ty = camY;
                }
                if (tx !== undefined && ty !== undefined) {
                    socket.send(JSON.stringify({ type: 'input', x: tx, y: ty }));
                }
            }
        }, 50);

        function massToRadius(m) { return 6 * Math.sqrt(m); }

        function draw() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            
            let myTotalMass = 0;
            let center = { x: 0, y: 0, count: 0 };
            
            if(isPlaying && localPlayers[myId]) {
                const p = localPlayers[myId];
                p.renderCells.forEach(c => {
                    center.x += c.x; center.y += c.y; center.count++;
                    myTotalMass += c.m;
                });
            } else if(isSpectating) {
                if (specFollowMode && gameState.leaderboard.length > 0) {
                    const topPlayer = gameState.leaderboard[0];
                    if(localPlayers[topPlayer.id]) {
                        const p = localPlayers[topPlayer.id];
                        p.renderCells.forEach(c => { center.x += c.x; center.y += c.y; center.count++; });
                    } else if (topPlayer.x !== undefined && topPlayer.y !== undefined) {
                         center.x = topPlayer.x;
                         center.y = topPlayer.y;
                         center.count = 1;
                    } else {
                        center.x = camX; center.y = camY; center.count=1;
                    }
                } else {
                    center.x = camX + (mouseX - camX) * 0.1; 
                    center.y = camY + (mouseY - camY) * 0.1;
                    center.count = 1;
                }
            }

            if(center.count > 0) {
                const tx = center.x / center.count;
                const ty = center.y / center.count;
                camX += (tx - camX) * 0.1;
                camY += (ty - camY) * 0.1;
            }
            
            if (isSpectating && !specFollowMode) {
                 camX = Math.max(0, Math.min(mapSize.w, camX));
                 camY = Math.max(0, Math.min(mapSize.h, camY));
            }

            if (myTotalMass > 0) {
                let autoScale = 1.0 / Math.pow(Math.min(64.0 / massToRadius(myTotalMass), 1), 0.4);
                targetCamScale = (0.8 / autoScale) * userZoomModifier;
            } else {
                targetCamScale = 0.5 * userZoomModifier;
            }
            camScale += (targetCamScale - camScale) * 0.1;

            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.scale(camScale, camScale);
            ctx.translate(-camX, -camY);

            const bgColor = isDarkTheme ? '#111' : '#f2fbff';
            const gridColor = isDarkTheme ? '#333' : '#ccc';
            const borderColor = isDarkTheme ? '#555' : '#333';
            
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, mapSize.w, mapSize.h);
            ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<=mapSize.w; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x, mapSize.h); }
            for(let y=0; y<=mapSize.h; y+=50) { ctx.moveTo(0,y); ctx.lineTo(mapSize.w, y); }
            ctx.stroke();
            ctx.strokeStyle = borderColor; ctx.lineWidth = 5; ctx.strokeRect(0,0, mapSize.w, mapSize.h);

            gameState.food.forEach(f => { ctx.fillStyle = f.color; ctx.beginPath(); ctx.arc(f.x, f.y, massToRadius(f.mass), 0, Math.PI*2); ctx.fill(); });
            gameState.ejected.forEach(e => { ctx.fillStyle = e.c; ctx.strokeStyle = isDarkTheme ? '#eee' : '#333'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(e.x, e.y, massToRadius(15), 0, Math.PI*2); ctx.fill(); ctx.stroke(); });
            gameState.viruses.forEach(v => {
                ctx.fillStyle = '#33ff33'; ctx.strokeStyle = '#22aa22'; ctx.lineWidth=4; ctx.beginPath(); 
                const r = massToRadius(v.m);
                for(let i=0; i<20; i++) {
                    const a = (i/20)*Math.PI*2;
                    const rad = i%2===0 ? r : r*0.92;
                    ctx.lineTo(v.x + Math.cos(a)*rad, v.y + Math.sin(a)*rad);
                }
                ctx.closePath(); ctx.fill(); ctx.stroke();
            });

            const sortedCells = [];
            for(let pid in localPlayers) {
                const p = localPlayers[pid];
                if(p.targetCells) {
                    for(let i=0; i<p.renderCells.length; i++) {
                        const rc = p.renderCells[i], tc = p.targetCells[i] || rc; 
                        rc.x += (tc.x - rc.x) * 0.2; rc.y += (tc.y - rc.y) * 0.2; rc.m += (tc.m - rc.m) * 0.2;
                        sortedCells.push({ ...rc, name: p.name, isMine: parseInt(pid)===myId });
                    }
                }
            }
            sortedCells.sort((a,b) => a.m - b.m); 
            sortedCells.forEach(c => {
                const r = massToRadius(c.m);
                ctx.fillStyle = c.c; ctx.strokeStyle = c.isMine ? '#fff' : (isDarkTheme ? '#000' : '#333'); ctx.lineWidth = c.isMine ? 4 : 2;
                ctx.beginPath(); ctx.arc(c.x, c.y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                if(r > 15) { 
                    ctx.fillStyle = '#fff'; ctx.strokeStyle='#000'; ctx.lineWidth=2;
                    ctx.font = `bold ${Math.max(12, r*0.4)}px sans-serif`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.strokeText(c.name, c.x, c.y); ctx.fillText(c.name, c.x, c.y);
                }
            });
            ctx.restore();
            
            let specText = "";
            if (isSpectating) {
                specText = specFollowMode ? "(Spectating: Top Player - Q to Free)" : "(Spectating: Free Roam - Q to Follow)";
            }
            document.getElementById('massDisplay').innerText = isPlaying ? Math.floor(myTotalMass) : specText;
            
            requestAnimationFrame(draw);
        }
        function updateLeaderboard() {
            const list = document.getElementById('lbList'); list.innerHTML = '';
            gameState.leaderboard.forEach((p, i) => {
                const li = document.createElement('li');
                if(p.id === myId) li.className = 'lb-me';
                li.innerHTML = `<span>${i+1}. ${p.name}</span> <span>${p.mass}</span>`;
                list.appendChild(li);
            });
        }
        let frameCount = 0;
        setInterval(() => { document.getElementById('fps').innerText = frameCount; frameCount = 0; }, 1000);
        function loop() { frameCount++; requestAnimationFrame(loop); } loop();
        fetchServerList(); requestAnimationFrame(draw);
    </script>
</body>
</html>